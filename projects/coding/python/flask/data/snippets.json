[
  {
    "id": "get_route",
    "name": "GET Route Example",
    "description": "Fetch data from the server using GET method.",
    "category": "routes",
    "method": "GET",
    "difficulty": "easy",
    "code": "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/items', methods=['GET'])\ndef get_items():\n    items = [{'id': 1, 'name': 'Item 1'}, {'id': 2, 'name': 'Item 2'}]\n    return jsonify(items)",
    "keywords": ["flask", "get", "api", "route", "json"],
    "tags": ["flask", "api", "json", "route", "get"],
    "requires": ["Flask"],
    "notes": "Use GET routes to fetch data from the server. Always return proper HTTP status codes.",
    "related": ["POST Route Example", "PUT Route Example", "DELETE Route Example"],
    "response": {
      "success": "Returns JSON data.",
      "error": "Returns an error message if fetching fails."
    }
  },
  {
    "id": "post_route",
    "name": "POST Route Example",
    "description": "Send data to the server to create a new resource.",
    "category": "routes",
    "method": "POST",
    "difficulty": "easy",
    "code": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/items', methods=['POST'])\ndef create_item():\n    data = request.json\n    # Validate data here\n    if not data.get('name'):\n        return jsonify({'error': 'Name is required'}), 400\n    \n    # Process and save data\n    new_item = {'id': 3, 'name': data['name']}\n    return jsonify({'message': 'Item created', 'item': new_item}), 201",
    "keywords": ["flask", "post", "api", "route", "json"],
    "tags": ["flask", "api", "json", "route", "post", "validation"],
    "requires": ["Flask"],
    "notes": "Always validate incoming data in POST routes. Return 201 status code for successful creation.",
    "related": ["GET Route Example", "PUT Route Example", "DELETE Route Example"],
    "response": {
      "success": "Returns confirmation of creation.",
      "error": "Returns validation errors if data is missing or invalid."
    }
  },
  {
    "id": "put_route",
    "name": "PUT Route Example",
    "description": "Update an existing resource on the server.",
    "category": "routes",
    "method": "PUT",
    "difficulty": "medium",
    "code": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\nitems = {1: {'name': 'Item 1'}, 2: {'name': 'Item 2'}}\n\n@app.route('/items/<int:item_id>', methods=['PUT'])\ndef update_item(item_id):\n    data = request.json\n    \n    if item_id not in items:\n        return jsonify({'error': 'Item not found'}), 404\n    \n    items[item_id].update(data)\n    return jsonify({'message': f'Item {item_id} updated', 'item': items[item_id]})",
    "keywords": ["flask", "put", "api", "route", "update"],
    "tags": ["flask", "api", "json", "route", "put", "update"],
    "requires": ["Flask"],
    "notes": "Use PUT routes to update resources; typically include the resource ID in the URL.",
    "related": ["GET Route Example", "POST Route Example", "DELETE Route Example"],
    "response": {
      "success": "Returns updated resource data.",
      "error": "Returns error if item does not exist or validation fails."
    }
  },
  {
    "id": "delete_route",
    "name": "DELETE Route Example",
    "description": "Remove an existing resource from the server.",
    "category": "routes",
    "method": "DELETE",
    "difficulty": "medium",
    "code": "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\nitems = {1: {'name': 'Item 1'}, 2: {'name': 'Item 2'}}\n\n@app.route('/items/<int:item_id>', methods=['DELETE'])\ndef delete_item(item_id):\n    if item_id not in items:\n        return jsonify({'error': 'Item not found'}), 404\n    \n    del items[item_id]\n    return jsonify({'message': f'Item {item_id} deleted'}), 200",
    "keywords": ["flask", "delete", "api", "route", "remove"],
    "tags": ["flask", "api", "json", "route", "delete"],
    "requires": ["Flask"],
    "notes": "Use DELETE routes to remove resources; include resource ID in the URL. Return 404 if not found.",
    "related": ["GET Route Example", "POST Route Example", "PUT Route Example"],
    "response": {
      "success": "Returns confirmation of deletion.",
      "error": "Returns error if item does not exist."
    }
  },
  {
    "id": "login_auth",
    "name": "Login Authentication",
    "description": "User login with session management.",
    "category": "auth",
    "method": "POST",
    "difficulty": "medium",
    "code": "from flask import Flask, request, session, jsonify\nfrom werkzeug.security import check_password_hash\n\napp = Flask(__name__)\napp.secret_key = 'your-secret-key-here'\n\nusers = {\n    'admin': {'password_hash': 'hashed_password_here'}\n}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    \n    if not username or not password:\n        return jsonify({'error': 'Username and password required'}), 400\n    \n    user = users.get(username)\n    if user and check_password_hash(user['password_hash'], password):\n        session['user_id'] = username\n        return jsonify({'message': 'Login successful'}), 200\n    \n    return jsonify({'error': 'Invalid credentials'}), 401",
    "keywords": ["flask", "login", "auth", "session", "authentication"],
    "tags": ["flask", "auth", "login", "session", "security"],
    "requires": ["Flask", "Werkzeug"],
    "notes": "Always use secure password hashing. Never store plain text passwords.",
    "related": ["Logout Function", "Register Route"],
    "response": {
      "success": "Returns login confirmation and sets session.",
      "error": "Returns error for invalid credentials."
    }
  },
  {
    "id": "sql_model",
    "name": "SQLAlchemy Model",
    "description": "Database model using SQLAlchemy ORM.",
    "category": "database",
    "method": "N/A",
    "difficulty": "medium",
    "code": "from flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\n\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    __tablename__ = 'users'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(200), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    is_active = db.Column(db.Boolean, default=True)\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'username': self.username,\n            'email': self.email,\n            'created_at': self.created_at.isoformat()\n        }",
    "keywords": ["flask", "sqlalchemy", "database", "model", "orm"],
    "tags": ["flask", "database", "sqlalchemy", "model", "orm"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "Define relationships between models using db.relationship().",
    "related": ["Database Setup", "CRUD Operations"],
    "response": {
      "success": "Model definition for database operations.",
      "error": "N/A"
    }
  },
  {
    "id": "advanced_form",
    "name": "Advanced Form Handling",
    "description": "Complex form with validation and file upload.",
    "category": "forms",
    "method": "POST",
    "difficulty": "hard",
    "code": "from flask import Flask, request, jsonify\nfrom werkzeug.utils import secure_filename\nimport os\n\napp = Flask(__name__)\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB limit\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\n# Helper function\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    # Get form data\n    username = request.form.get('username')\n    email = request.form.get('email')\n    \n    # Validate form data\n    if not username or not email:\n        return jsonify({'error': 'Username and email are required'}), 400\n    \n    # Handle file upload\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part'}), 400\n    \n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    \n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        # Save file to uploads folder\n        file.save(os.path.join('uploads', filename))\n        return jsonify({\n            'message': 'File uploaded successfully',\n            'username': username,\n            'email': email,\n            'filename': filename\n        }), 200\n    \n    return jsonify({'error': 'File type not allowed'}), 400",
    "keywords": ["flask", "form", "upload", "validation", "file"],
    "tags": ["flask", "forms", "upload", "validation", "files"],
    "requires": ["Flask", "Werkzeug"],
    "notes": "Always validate file extensions and use secure_filename(). Set appropriate file size limits.",
    "related": ["Simple Form", "Form Validation"],
    "response": {
      "success": "Returns uploaded file info.",
      "error": "Returns validation errors."
    }
  },
  {
    "id": "simple_form",
    "name": "Simple Form Handling",
    "description": "Basic form submission and validation.",
    "category": "forms",
    "method": "POST",
    "difficulty": "easy",
    "code": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/submit-form', methods=['POST'])\ndef submit_form():\n    name = request.form.get('name')\n    email = request.form.get('email')\n    message = request.form.get('message', '')\n    \n    # Basic validation\n    errors = []\n    if not name:\n        errors.append('Name is required')\n    if not email:\n        errors.append('Email is required')\n    elif '@' not in email:\n        errors.append('Valid email is required')\n    \n    if errors:\n        return jsonify({'errors': errors}), 400\n    \n    # Process the form data (e.g., save to database, send email)\n    # ...\n    \n    return jsonify({\n        'message': 'Form submitted successfully',\n        'data': {\n            'name': name,\n            'email': email,\n            'message': message[:100]  # Limit message preview\n        }\n    }), 200",
    "keywords": ["flask", "form", "validation", "submit", "basic"],
    "tags": ["flask", "forms", "validation", "basic"],
    "requires": ["Flask"],
    "notes": "Always validate user input on the server side, even if you have client-side validation.",
    "related": ["Advanced Form", "Form Validation"],
    "response": {
      "success": "Returns form submission confirmation.",
      "error": "Returns validation errors."
    }
  },
  {
    "id": "logout_auth",
    "name": "Logout Function",
    "description": "User logout with session cleanup.",
    "category": "auth",
    "method": "POST",
    "difficulty": "easy",
    "code": "from flask import Flask, session, jsonify\n\napp = Flask(__name__)\napp.secret_key = 'your-secret-key-here'\n\n@app.route('/logout', methods=['POST'])\ndef logout():\n    # Check if user is logged in\n    if 'user_id' not in session:\n        return jsonify({'error': 'Not logged in'}), 400\n    \n    # Clear the session\n    session.clear()\n    \n    return jsonify({'message': 'Logout successful'}), 200\n\n# Alternative: Using decorator for protected routes\nfrom functools import wraps\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'user_id' not in session:\n            return jsonify({'error': 'Authentication required'}), 401\n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/protected')\n@login_required\ndef protected_route():\n    return jsonify({'message': 'This is a protected route'})",
    "keywords": ["flask", "logout", "auth", "session", "protected"],
    "tags": ["flask", "auth", "logout", "session", "decorator"],
    "requires": ["Flask"],
    "notes": "Always clear session data on logout. Use decorators for route protection.",
    "related": ["Login Authentication", "Session Management"],
    "response": {
      "success": "Returns logout confirmation.",
      "error": "Returns error if not logged in."
    }
  },
  {
    "id": "db_setup_sqlalchemy",
    "name": "Database Setup with SQLAlchemy",
    "description": "How to configure and initialize Flask-SQLAlchemy for database integration.",
    "category": "database",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\n# Configure the database URI (using SQLite here)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///mydatabase.db'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\n# Initialize the extension\ndb = SQLAlchemy(app)\n\n# To create the database and tables from your models:\n# In your terminal, run:\n# > flask shell\n# >>> from yourapp import db\n# >>> db.create_all()",
    "keywords": ["flask", "sqlalchemy", "database", "setup", "configuration", "orm"],
    "tags": ["flask", "database", "sqlalchemy", "setup"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "The database URI format depends on the database used (e.g., PostgreSQL, MySQL). 'sqlite:///test.db' creates a file-based SQLite database. It's recommended to set SQLALCHEMY_TRACK_MODIFICATIONS to False to disable a feature that signals the application every time a change is about to be made in the database, which can be resource-intensive.",
    "related": ["sql_model", "create_record_sqlalchemy"],
    "response": {
      "success": "Application is configured to use a database.",
      "error": "N/A"
    }
  },
  {
    "id": "create_record_sqlalchemy",
    "name": "Create a Record (SQLAlchemy)",
    "description": "Create and save a new record to the database using SQLAlchemy.",
    "category": "database",
    "method": "POST",
    "difficulty": "easy",
    "code": "from flask import request, jsonify\nfrom .models import db, User # Assuming models are in models.py\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    if not data or not 'username' in data or not 'email' in data:\n        return jsonify({'error': 'Missing data'}), 400\n\n    new_user = User(username=data['username'], email=data['email'])\n    \n    db.session.add(new_user)\n    db.session.commit()\n    \n    return jsonify({'message': 'User created', 'user': new_user.to_dict()}), 201",
    "keywords": ["flask", "sqlalchemy", "create", "insert", "crud"],
    "tags": ["flask", "database", "sqlalchemy", "crud", "create"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "Always commit the session after adding, updating, or deleting records. Assumes a `to_dict()` method on the model for serialization.",
    "related": ["sql_model", "read_all_records_sqlalchemy"],
    "response": {
      "success": "Returns the newly created user object.",
      "error": "Returns an error if required data is missing."
    }
  },
  {
    "id": "read_all_records_sqlalchemy",
    "name": "Read All Records (SQLAlchemy)",
    "description": "Query and retrieve all records from a database table.",
    "category": "database",
    "method": "GET",
    "difficulty": "easy",
    "code": "from flask import jsonify\nfrom .models import User # Assuming User model is defined\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    return jsonify([user.to_dict() for user in users])",
    "keywords": ["flask", "sqlalchemy", "read", "query", "select", "all"],
    "tags": ["flask", "database", "sqlalchemy", "crud", "read"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "The `.all()` method executes the query and returns a list of all results. For large datasets, consider using pagination.",
    "related": ["read_one_record_sqlalchemy", "db_query_pagination"],
    "response": {
      "success": "Returns a list of all user objects.",
      "error": "N/A"
    }
  },
  {
    "id": "read_one_record_sqlalchemy",
    "name": "Read One Record (SQLAlchemy)",
    "description": "Query and retrieve a single record by its primary key.",
    "category": "database",
    "method": "GET",
    "difficulty": "easy",
    "code": "from flask import jsonify\nfrom .models import User # Assuming User model is defined\n\n@app.route('/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    user = User.query.get_or_404(user_id)\n    return jsonify(user.to_dict())",
    "keywords": ["flask", "sqlalchemy", "read", "query", "select", "get"],
    "tags": ["flask", "database", "sqlalchemy", "crud", "read"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "`.get_or_404(id)` is a convenient Flask-SQLAlchemy method that fetches a record by its primary key or aborts with a 404 Not Found error if it doesn't exist.",
    "related": ["read_all_records_sqlalchemy", "update_record_sqlalchemy"],
    "response": {
      "success": "Returns the specified user object.",
      "error": "Returns a 404 error if the user is not found."
    }
  },
  {
    "id": "update_record_sqlalchemy",
    "name": "Update a Record (SQLAlchemy)",
    "description": "Find and update an existing record in the database.",
    "category": "database",
    "method": "PUT",
    "difficulty": "medium",
    "code": "from flask import request, jsonify\nfrom .models import db, User # Assuming models are defined\n\n@app.route('/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    user = User.query.get_or_404(user_id)\n    data = request.get_json()\n\n    user.username = data.get('username', user.username)\n    user.email = data.get('email', user.email)\n    \n    db.session.commit()\n    \n    return jsonify({'message': 'User updated', 'user': user.to_dict()})",
    "keywords": ["flask", "sqlalchemy", "update", "edit", "crud"],
    "tags": ["flask", "database", "sqlalchemy", "crud", "update"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "Fetch the existing record first, then modify its attributes with the new data. Finally, commit the session to save the changes.",
    "related": ["read_one_record_sqlalchemy", "delete_record_sqlalchemy"],
    "response": {
      "success": "Returns the updated user object.",
      "error": "Returns a 404 error if the user is not found."
    }
  },
  {
    "id": "delete_record_sqlalchemy",
    "name": "Delete a Record (SQLAlchemy)",
    "description": "Find and delete an existing record from the database.",
    "category": "database",
    "method": "DELETE",
    "difficulty": "medium",
    "code": "from flask import jsonify\nfrom .models import db, User # Assuming models are defined\n\n@app.route('/users/<int:user_id>', methods=['DELETE'])\ndef delete_user(user_id):\n    user = User.query.get_or_404(user_id)\n    \n    db.session.delete(user)\n    db.session.commit()\n    \n    return jsonify({'message': 'User deleted'}), 200",
    "keywords": ["flask", "sqlalchemy", "delete", "remove", "crud"],
    "tags": ["flask", "database", "sqlalchemy", "crud", "delete"],
    "requires": ["Flask", "Flask-SQLAlchemy"],
    "notes": "Use `db.session.delete()` to mark an object for deletion, then commit the session to apply the change to the database.",
    "related": ["read_one_record_sqlalchemy", "update_record_sqlalchemy"],
    "response": {
      "success": "Returns a confirmation message.",
      "error": "Returns a 404 error if the user is not found."
    }
  },
  {
    "id": "one_to_many_relationship",
    "name": "One-to-Many Relationship Model",
    "description": "Define a one-to-many relationship between two SQLAlchemy models (e.g., a User has many Posts).",
    "category": "database",
    "method": "N/A",
    "difficulty": "medium",
    "code": "from . import db # Assuming db = SQLAlchemy()\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    # The 'posts' relationship will provide a list of Post objects\n    posts = db.relationship('Post', backref='author', lazy=True)\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(120), nullable=False)\n    # The foreign key links a post to a user\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)",
    "keywords": ["flask", "sqlalchemy", "relationship", "one-to-many", "foreignkey"],
    "tags": ["flask", "database", "sqlalchemy", "model", "relationship"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "`db.relationship` defines the high-level view of the relationship. `db.ForeignKey` is a database-level constraint. The `backref` argument creates a virtual `author` attribute on the `Post` model.",
    "related": ["sql_model", "many_to_many_relationship"],
    "response": {
      "success": "Defines a one-to-many relationship between models.",
      "error": "N/A"
    }
  },
  {
    "id": "many_to_many_relationship",
    "name": "Many-to-Many Relationship Model",
    "description": "Define a many-to-many relationship using an association table (e.g., a Post can have many Tags).",
    "category": "database",
    "method": "N/A",
    "difficulty": "hard",
    "code": "from . import db # Assuming db = SQLAlchemy()\n\n# Association table for the many-to-many relationship\ntags = db.Table('tags',\n    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'), primary_key=True),\n    db.Column('post_id', db.Integer, db.ForeignKey('post.id'), primary_key=True)\n)\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(120), nullable=False)\n    tags = db.relationship('Tag', secondary=tags, lazy='subquery',\n        backref=db.backref('posts', lazy=True))\n\nclass Tag(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False)",
    "keywords": ["flask", "sqlalchemy", "relationship", "many-to-many", "association"],
    "tags": ["flask", "database", "sqlalchemy", "model", "relationship"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "A many-to-many relationship requires a helper table (the association table) that doesn't contain any data other than the foreign keys to the related tables. This table is passed as the `secondary` argument to `db.relationship()`.",
    "related": ["sql_model", "one_to_many_relationship"],
    "response": {
      "success": "Defines a many-to-many relationship between models.",
      "error": "N/A"
    }
  },
  {
    "id": "db_migrations_init",
    "name": "Database Migrations Setup (Flask-Migrate)",
    "description": "Initialize database migrations for your application using Flask-Migrate.",
    "category": "database",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# app.py\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\ndb = SQLAlchemy(app)\nmigrate = Migrate(app, db)\n\n# In your terminal, run:\n# > flask db init\n# This creates a 'migrations' directory.",
    "keywords": ["flask", "sqlalchemy", "migrate", "alembic", "database", "migrations"],
    "tags": ["flask", "database", "sqlalchemy", "migrations"],
    "requires": ["Flask", "Flask-SQLAlchemy", "Flask-Migrate"],
    "notes": "Flask-Migrate, which uses Alembic, handles SQLAlchemy database migrations for Flask applications. The `init` command only needs to be run once to set up the migration repository.",
    "related": ["db_migrations_migrate", "db_migrations_upgrade"],
    "response": {
      "success": "Initializes the migration environment.",
      "error": "N/A"
    }
  },
  {
    "id": "db_migrations_migrate",
    "name": "Creating a Database Migration",
    "description": "Automatically generate a new migration script based on changes to your models.",
    "category": "database",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# After changing your db.Model classes (e.g., adding a new column)\n\n# In your terminal, run:\n# > flask db migrate -m \"Add new column to user model\"\n\n# This will generate a new script in the migrations/versions/ directory.\n# Always review the generated migration script before applying it.",
    "keywords": ["flask", "sqlalchemy", "migrate", "alembic", "database", "migrations"],
    "tags": ["flask", "database", "sqlalchemy", "migrations"],
    "requires": ["Flask-Migrate"],
    "notes": "The `migrate` command compares the current state of your models against the current state of the database and generates the necessary changes as a migration script.",
    "related": ["db_migrations_init", "db_migrations_upgrade"],
    "response": {
      "success": "Generates a new migration script.",
      "error": "N/A"
    }
  },
  {
    "id": "db_migrations_upgrade",
    "name": "Applying a Database Migration",
    "description": "Apply the latest migration script to update the database schema.",
    "category": "database",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# To apply the migration to the database:\n\n# In your terminal, run:\n# > flask db upgrade\n\n# To revert the last migration, you can use:\n# > flask db downgrade",
    "keywords": ["flask", "sqlalchemy", "migrate", "alembic", "database", "upgrade"],
    "tags": ["flask", "database", "sqlalchemy", "migrations"],
    "requires": ["Flask-Migrate"],
    "notes": "The `upgrade` command applies all migrations that have not yet been applied to the database. This is how you synchronize your database schema with your models.",
    "related": ["db_migrations_init", "db_migrations_migrate"],
    "response": {
      "success": "Updates the database schema to the latest version.",
      "error": "N/A"
    }
  },
  {
    "id": "db_query_filter",
    "name": "Filtering Query Results",
    "description": "Use `filter()` and `filter_by()` to add WHERE clauses to your database queries.",
    "category": "database",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from .models import User\n\n# filter_by() for simple key-value queries\nactive_users = User.query.filter_by(is_active=True).all()\n\n# filter() for more complex expressions\nfrom sqlalchemy import or_\nusers = User.query.filter(or_(User.username == 'admin', User.email.like('%@example.com'))).all()",
    "keywords": ["flask", "sqlalchemy", "query", "filter", "where"],
    "tags": ["flask", "database", "sqlalchemy", "query"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "`filter_by()` is convenient for simple equality checks. `filter()` is more powerful and allows for standard Python comparison operators (e.g., `User.id > 5`) and SQL expressions.",
    "related": ["read_all_records_sqlalchemy", "db_query_orderby"],
    "response": {
      "success": "Returns a filtered list of results.",
      "error": "N/A"
    }
  },
  {
    "id": "db_query_orderby",
    "name": "Ordering Query Results",
    "description": "Use `order_by()` to sort the results of a database query.",
    "category": "database",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from .models import User\nfrom sqlalchemy import desc\n\n# Get users ordered by username alphabetically\nusers_by_name = User.query.order_by(User.username).all()\n\n# Get users ordered by creation date, newest first\nnewest_users = User.query.order_by(desc(User.created_at)).all()",
    "keywords": ["flask", "sqlalchemy", "query", "order by", "sort"],
    "tags": ["flask", "database", "sqlalchemy", "query"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "Pass the model column to `order_by()`. To sort in descending order, wrap the column with `desc()` from SQLAlchemy.",
    "related": ["db_query_filter", "db_query_pagination"],
    "response": {
      "success": "Returns a sorted list of results.",
      "error": "N/A"
    }
  },
  {
    "id": "db_query_pagination",
    "name": "Paginating Query Results",
    "description": "Use the `paginate()` method to easily paginate large sets of query results.",
    "category": "database",
    "method": "GET",
    "difficulty": "medium",
    "code": "from flask import request, jsonify\nfrom .models import Post\n\n@app.route('/posts')\ndef get_posts():\n    page = request.args.get('page', 1, type=int)\n    per_page = request.args.get('per_page', 10, type=int)\n    \n    # The paginate() method returns a Pagination object\n    pagination = Post.query.order_by(Post.timestamp.desc()).paginate(\n        page=page, per_page=per_page, error_out=False\n    )\n    \n    posts = pagination.items\n    return jsonify({\n        'posts': [post.to_dict() for post in posts],\n        'total_pages': pagination.pages,\n        'current_page': page,\n        'has_next': pagination.has_next\n    })",
    "keywords": ["flask", "sqlalchemy", "query", "pagination", "limit", "offset"],
    "tags": ["flask", "database", "sqlalchemy", "pagination"],
    "requires": ["Flask-SQLAlchemy"],
    "notes": "`paginate()` is a Flask-SQLAlchemy specific method that simplifies pagination. It returns an object with useful properties like `items`, `pages`, `has_next`, and `has_prev`.",
    "related": ["db_query_orderby", "read_all_records_sqlalchemy"],
    "response": {
      "success": "Returns a paginated list of results and pagination metadata.",
      "error": "N/A"
    }
  },
  {
    "id": "register_user",
    "name": "Register User Route",
    "description": "A route for new user registration that includes password hashing.",
    "category": "auth",
    "method": "POST",
    "difficulty": "medium",
    "code": "from flask import request, jsonify\nfrom werkzeug.security import generate_password_hash\nfrom .models import db, User\n\n@app.route('/register', methods=['POST'])\ndef register():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n\n    if not username or not password:\n        return jsonify({'error': 'Username and password required'}), 400\n\n    if User.query.filter_by(username=username).first():\n        return jsonify({'error': 'Username already exists'}), 409\n\n    hashed_password = generate_password_hash(password)\n    new_user = User(username=username, password_hash=hashed_password)\n    db.session.add(new_user)\n    db.session.commit()\n\n    return jsonify({'message': 'User registered successfully'}), 201",
    "keywords": ["flask", "register", "auth", "user", "password", "hash"],
    "tags": ["flask", "auth", "register", "security"],
    "requires": ["Flask", "Werkzeug", "Flask-SQLAlchemy"],
    "notes": "Always hash passwords before storing them in the database. `generate_password_hash` from Werkzeug is a secure way to do this. Check for existing usernames to avoid duplicates.",
    "related": ["login_auth", "hashing_password"],
    "response": {
      "success": "Confirms user registration.",
      "error": "Returns error for missing data or duplicate username."
    }
  },
  {
    "id": "jwt_create_token",
    "name": "Create a JWT Token",
    "description": "Generate a JSON Web Token (JWT) for a user upon successful login.",
    "category": "auth",
    "method": "POST",
    "difficulty": "medium",
    "code": "import jwt\nimport datetime\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-super-secret-key'\n\n@app.route('/api/login', methods=['POST'])\ndef api_login():\n    # ... (user authentication logic here) ...\n    auth = request.authorization\n    if auth and auth.username == 'test' and auth.password == 'password':\n        token = jwt.encode({\n            'user': auth.username,\n            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30)\n        }, app.config['SECRET_KEY'], algorithm='HS256')\n        return jsonify({'token': token})\n\n    return jsonify({'error': 'Invalid credentials'}), 401",
    "keywords": ["flask", "jwt", "token", "auth", "api", "authentication"],
    "tags": ["flask", "auth", "jwt", "api", "security"],
    "requires": ["Flask", "PyJWT"],
    "notes": "JWTs are a common way to handle authentication in stateless APIs. The payload should include an expiration claim (`exp`) to limit the token's validity.",
    "related": ["jwt_auth_decorator", "login_auth"],
    "response": {
      "success": "Returns a JWT token for the authenticated user.",
      "error": "Returns an error for invalid credentials."
    }
  },
  {
    "id": "jwt_auth_decorator",
    "name": "JWT Authentication Decorator",
    "description": "Create a decorator to protect routes, requiring a valid JWT.",
    "category": "auth",
    "method": "N/A",
    "difficulty": "hard",
    "code": "from functools import wraps\nimport jwt\nfrom flask import request, jsonify, current_app\n\ndef token_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n        if 'x-access-token' in request.headers:\n            token = request.headers['x-access-token']\n\n        if not token:\n            return jsonify({'message': 'Token is missing!'}), 401\n\n        try:\n            data = jwt.decode(token, current_app.config['SECRET_KEY'], algorithms=['HS256'])\n            # You can pass the decoded data to the route if needed\n            # current_user = User.query.filter_by(public_id=data['public_id']).first()\n        except jwt.ExpiredSignatureError:\n            return jsonify({'message': 'Token has expired!'}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({'message': 'Token is invalid!'}), 401\n\n        return f(*args, **kwargs)\n    return decorated\n\n@app.route('/api/protected')\n@token_required\ndef protected_resource():\n    return jsonify({'message': 'This is a protected resource!'})",
    "keywords": ["flask", "jwt", "token", "auth", "decorator", "protected"],
    "tags": ["flask", "auth", "jwt", "api", "decorator"],
    "requires": ["Flask", "PyJWT"],
    "notes": "This decorator checks for a token in the request headers, decodes it, and handles common errors like missing, expired, or invalid tokens.",
    "related": ["jwt_create_token", "logout_auth"],
    "response": {
      "success": "Allows access to the route if the token is valid.",
      "error": "Returns a 401 error if the token is missing or invalid."
    }
  },
  {
    "id": "create_blueprint",
    "name": "Creating a Blueprint",
    "description": "Define a Blueprint to organize a group of related views and other code.",
    "category": "blueprints",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Blueprint, jsonify\n\n# Create a Blueprint named 'users'\n# The first argument is the blueprint's name.\n# The second is the import name, usually __name__.\nusers_bp = Blueprint('users', __name__)\n\n@users_bp.route('/users')\ndef get_users():\n    # This view is now part of the 'users_bp' blueprint\n    return jsonify([{'id': 1, 'username': 'john_doe'}])",
    "keywords": ["flask", "blueprint", "organization", "modular", "structure"],
    "tags": ["flask", "blueprints", "structure"],
    "requires": ["Flask"],
    "notes": "Blueprints help in structuring larger applications. They can be registered on an application, optionally with a URL prefix and/or subdomain.",
    "related": ["register_blueprint", "blueprint_url_prefix"],
    "response": {
      "success": "A modular component (Blueprint) is created.",
      "error": "N/A"
    }
  },
  {
    "id": "register_blueprint",
    "name": "Registering a Blueprint",
    "description": "Register a blueprint with the main Flask application.",
    "category": "blueprints",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Flask\n# Assuming users_bp is defined in a file called 'routes.py'\nfrom .routes import users_bp\n\napp = Flask(__name__)\n\n# Register the blueprint with the app\napp.register_blueprint(users_bp)\n\n# The routes defined in users_bp are now active in the application.",
    "keywords": ["flask", "blueprint", "register", "app", "structure"],
    "tags": ["flask", "blueprints", "structure"],
    "requires": ["Flask"],
    "notes": "Once a blueprint is registered, all the routes, error handlers, and other functions it contains are added to the application.",
    "related": ["create_blueprint", "blueprint_url_prefix"],
    "response": {
      "success": "The blueprint's routes are added to the application.",
      "error": "N/A"
    }
  },
  {
    "id": "blueprint_url_prefix",
    "name": "Blueprint with URL Prefix",
    "description": "Register a blueprint with a common URL prefix for all its routes.",
    "category": "blueprints",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Flask\nfrom .routes import users_bp # from create_blueprint example\n\napp = Flask(__name__)\n\n# All routes in users_bp will be prefixed with '/api/v1'\n# e.g., the '/users' route becomes '/api/v1/users'\napp.register_blueprint(users_bp, url_prefix='/api/v1')",
    "keywords": ["flask", "blueprint", "prefix", "url", "api", "versioning"],
    "tags": ["flask", "blueprints", "routing", "api"],
    "requires": ["Flask"],
    "notes": "Using `url_prefix` is a very common pattern for versioning APIs or grouping related endpoints under a single path.",
    "related": ["create_blueprint", "register_blueprint", "api_versioning_blueprint"],
    "response": {
      "success": "The blueprint is registered with a URL prefix.",
      "error": "N/A"
    }
  },
  {
    "id": "error_handler_404",
    "name": "Custom 404 Error Handler",
    "description": "Create a custom view to handle 404 Not Found errors.",
    "category": "error_handling",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef not_found_error(error):\n    return jsonify({'error': 'Not Found', 'message': 'The requested URL was not found on the server.'}), 404",
    "keywords": ["flask", "error", "handler", "404", "not found"],
    "tags": ["flask", "errors", "routing"],
    "requires": ["Flask"],
    "notes": "The `@app.errorhandler()` decorator registers a function to handle a specific HTTP error code. This allows you to return custom, user-friendly error responses, such as in JSON format for an API.",
    "related": ["error_handler_500", "abort_request"],
    "response": {
      "success": "Returns a custom JSON response for 404 errors.",
      "error": "N/A"
    }
  },
  {
    "id": "error_handler_500",
    "name": "Custom 500 Error Handler",
    "description": "Create a custom view to handle 500 Internal Server Errors.",
    "category": "error_handling",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.errorhandler(500)\ndef internal_server_error(error):\n    # You might want to log the error here\n    # db.session.rollback() # If using a database\n    return jsonify({'error': 'Internal Server Error', 'message': 'Something went wrong on our end.'}), 500\n\n@app.route('/error')\ndef trigger_error():\n    # This will trigger the 500 handler\n    return 1 / 0",
    "keywords": ["flask", "error", "handler", "500", "internal server error"],
    "tags": ["flask", "errors", "debugging"],
    "requires": ["Flask"],
    "notes": "A 500 error handler is crucial for production applications to avoid showing users stack traces. It's a good place to perform cleanup, like rolling back database transactions.",
    "related": ["error_handler_404", "logging_configuration"],
    "response": {
      "success": "Returns a custom JSON response for 500 errors.",
      "error": "N/A"
    }
  },
  {
    "id": "abort_request",
    "name": "Aborting a Request",
    "description": "Use `abort()` to immediately stop a request and return an HTTP error code.",
    "category": "error_handling",
    "method": "GET",
    "difficulty": "easy",
    "code": "from flask import abort, jsonify\n\n@app.route('/items/<int:item_id>')\ndef get_item(item_id):\n    # Example: item does not exist\n    if item_id > 100:\n        # This will trigger the 404 error handler\n        abort(404, description=\"Item not found in our records.\")\n    \n    return jsonify({'id': item_id, 'name': f'Item {item_id}'})",
    "keywords": ["flask", "error", "abort", "http", "status code"],
    "tags": ["flask", "errors", "routing"],
    "requires": ["Flask"],
    "notes": "`abort(code)` is the standard way to signal an error within a view function. It raises an `HTTPException` that Flask's routing system catches to invoke the appropriate error handler.",
    "related": ["error_handler_404", "put_route"],
    "response": {
      "success": "Returns item data if found.",
      "error": "Aborts with a 404 error if the item is not found."
    }
  },
  {
    "id": "config_from_object",
    "name": "Configuration from Object",
    "description": "Load Flask application configuration from a Python class or object.",
    "category": "configuration",
    "method": "N/A",
    "difficulty": "easy",
    "code": "# config.py\nclass Config:\n    DEBUG = False\n    TESTING = False\n    SECRET_KEY = 'your-secret-key'\n\nclass DevelopmentConfig(Config):\n    DEBUG = True\n\nclass ProductionConfig(Config):\n    # Production specific config, e.g., DATABASE_URI\n    pass\n\n# app.py\nfrom flask import Flask\nimport config\n\napp = Flask(__name__)\napp.config.from_object(config.DevelopmentConfig)",
    "keywords": ["flask", "config", "configuration", "object", "settings"],
    "tags": ["flask", "config", "structure"],
    "requires": ["Flask"],
    "notes": "This is a common and clean way to manage different configuration environments (development, testing, production). Configuration keys must be uppercase.",
    "related": ["config_from_pyfile", "config_from_envvar"],
    "response": {
      "success": "Application configuration is loaded from a Python object.",
      "error": "N/A"
    }
  },
  {
    "id": "config_from_envvar",
    "name": "Configuration from Environment Variable",
    "description": "Load a configuration file specified by an environment variable.",
    "category": "configuration",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# In your terminal:\n# > export APP_SETTINGS=/path/to/settings.cfg\n\n# In your application code (app.py):\nfrom flask import Flask\n\napp = Flask(__name__)\n\n# This will load the file specified by the env var.\n# The `silent=True` argument prevents it from crashing if the var is not set.\napp.config.from_envvar('APP_SETTINGS', silent=True)\n\n# settings.cfg file content:\n# SECRET_KEY = 'a-different-secret-key'\n# DEBUG = True",
    "keywords": ["flask", "config", "configuration", "environment", "variable", "envvar"],
    "tags": ["flask", "config", "deployment"],
    "requires": ["Flask"],
    "notes": "This method is very flexible for deployment, as it allows you to change configuration without modifying the application code. It's useful for pointing to different config files in different environments.",
    "related": ["config_from_object", "gunicorn_wsgi_entry"],
    "response": {
      "success": "Application configuration is loaded from a file path stored in an environment variable.",
      "error": "N/A"
    }
  },
  {
    "id": "pytest_client_fixture",
    "name": "Pytest Test Client Fixture",
    "description": "Set up a test client fixture in `conftest.py` for use in Pytest tests.",
    "category": "testing",
    "method": "N/A",
    "difficulty": "easy",
    "code": "# tests/conftest.py\nimport pytest\nfrom my_app import create_app # Assuming you have an app factory\n\n@pytest.fixture\ndef app():\n    app = create_app({'TESTING': True})\n    yield app\n\n@pytest.fixture\ndef client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()",
    "keywords": ["flask", "test", "pytest", "fixture", "client"],
    "tags": ["flask", "testing", "pytest"],
    "requires": ["Flask", "pytest"],
    "notes": "Fixtures are a core feature of Pytest. Defining a `client` fixture in `conftest.py` makes it automatically available to all your test functions, reducing boilerplate code.",
    "related": ["test_get_endpoint", "test_post_endpoint"],
    "response": {
      "success": "Provides a reusable test client for making requests to the app.",
      "error": "N/A"
    }
  },
  {
    "id": "test_get_endpoint",
    "name": "Testing a GET Endpoint",
    "description": "Write a Pytest test to verify the behavior of a GET endpoint.",
    "category": "testing",
    "method": "N/A",
    "difficulty": "easy",
    "code": "# tests/test_routes.py\n\ndef test_get_items(client):\n    \"\"\"Test that the /items endpoint returns a 200 OK and JSON data.\"\"\"\n    response = client.get('/items')\n    assert response.status_code == 200\n    assert response.headers['Content-Type'] == 'application/json'\n    \n    json_data = response.get_json()\n    assert isinstance(json_data, list)\n    # Further assertions on the data content\n    assert len(json_data) > 0\n    assert 'name' in json_data[0]",
    "keywords": ["flask", "test", "pytest", "get", "endpoint", "api"],
    "tags": ["flask", "testing", "pytest", "api"],
    "requires": ["Flask", "pytest"],
    "notes": "Use the test client to make requests to your application's endpoints. Assert the status code, headers, and response data to ensure the endpoint is working as expected.",
    "related": ["pytest_client_fixture", "test_post_endpoint"],
    "response": {
      "success": "Verifies the correctness of a GET endpoint.",
      "error": "N/A"
    }
  },
  {
    "id": "test_post_endpoint",
    "name": "Testing a POST Endpoint",
    "description": "Write a Pytest test for a POST endpoint, including sending JSON data.",
    "category": "testing",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# tests/test_routes.py\nimport json\n\ndef test_create_item(client):\n    \"\"\"Test creating a new item via POST request.\"\"\"\n    new_item = {'name': 'New Test Item'}\n    response = client.post('/items',\n                           data=json.dumps(new_item),\n                           content_type='application/json')\n\n    assert response.status_code == 201\n    json_data = response.get_json()\n    assert json_data['message'] == 'Item created'\n    assert json_data['item']['name'] == 'New Test Item'",
    "keywords": ["flask", "test", "pytest", "post", "json", "api"],
    "tags": ["flask", "testing", "pytest", "api"],
    "requires": ["Flask", "pytest"],
    "notes": "When testing POST requests with JSON payloads, use `json.dumps()` to serialize your data and set the `content_type` header to `application/json`.",
    "related": ["pytest_client_fixture", "test_get_endpoint"],
    "response": {
      "success": "Verifies the creation logic of a POST endpoint.",
      "error": "N/A"
    }
  },
  {
    "id": "wtf_simple_form",
    "name": "Simple Form with Flask-WTF",
    "description": "Define a simple login form using Flask-WTF and WTForms.",
    "category": "forms",
    "method": "N/A",
    "difficulty": "easy",
    "code": "from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Email\n\nclass LoginForm(FlaskForm):\n    \"\"\"A simple user login form.\"\"\"\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[DataRequired()])\n    submit = SubmitField('Log In')",
    "keywords": ["flask", "forms", "wtf", "wtforms", "validation"],
    "tags": ["flask", "forms", "wtforms", "validation"],
    "requires": ["Flask-WTF"],
    "notes": "Flask-WTF integrates WTForms with Flask. You define forms as classes inheriting from `FlaskForm`. Fields are class attributes, and validators are passed as a list to the `validators` argument.",
    "related": ["wtf_form_template", "simple_form"],
    "response": {
      "success": "Defines a reusable form class with built-in validation.",
      "error": "N/A"
    }
  },
  {
    "id": "wtf_form_template",
    "name": "Rendering a WTForms Form in Jinja2",
    "description": "Render a Flask-WTF form in a Jinja2 template and handle its submission.",
    "category": "forms",
    "method": "GET/POST",
    "difficulty": "easy",
    "code": "# view.py\nfrom flask import render_template, redirect, url_for\nfrom .forms import LoginForm\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        # Process login here\n        return redirect(url_for('index'))\n    return render_template('login.html', title='Sign In', form=form)\n\n# login.html (template)\n\"\"\"<form action=\"\" method=\"post\" novalidate>\n    {{ form.hidden_tag() }}  {# CSRF token #}\n    <p>\n        {{ form.email.label }}<br>\n        {{ form.email(size=32) }}\n        {% for error in form.email.errors %}\n        <span style=\"color: red;\">[{{ error }}]</span>\n        {% endfor %}\n    </p>\n    <p>{{ form.password.label }}<br>{{ form.password(size=32) }}</p>\n    <p>{{ form.submit() }}</p>\n</form>\"\"\"",
    "keywords": ["flask", "forms", "wtf", "wtforms", "template", "jinja2"],
    "tags": ["flask", "forms", "wtforms", "templates"],
    "requires": ["Flask-WTF"],
    "notes": "`form.validate_on_submit()` is a convenient method that returns `True` if the request is a POST/PUT and the form data is valid. `form.hidden_tag()` renders the CSRF token, which is crucial for security.",
    "related": ["wtf_simple_form", "csrf_protection_wtf"],
    "response": {
      "success": "Renders a form and processes its submission upon validation.",
      "error": "Re-renders the form with validation errors if submission is invalid."
    }
  },
  {
    "id": "template_render",
    "name": "Render a Simple Template",
    "description": "Use `render_template()` to render an HTML file from the `templates` folder.",
    "category": "templates",
    "method": "GET",
    "difficulty": "easy",
    "code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    # Flask will look for 'index.html' in a 'templates' directory\n    # in the same level as your app.py\n    return render_template('index.html')",
    "keywords": ["flask", "template", "render", "jinja2", "html"],
    "tags": ["flask", "templates", "jinja2"],
    "requires": ["Flask"],
    "notes": "By convention, Flask looks for templates in a folder named `templates`. The `render_template` function automatically uses the Jinja2 templating engine.",
    "related": ["template_variables", "template_loop"],
    "response": {
      "success": "Returns an HTML response rendered from a template file.",
      "error": "N/A"
    }
  },
  {
    "id": "template_variables",
    "name": "Passing Variables to a Template",
    "description": "Pass Python variables from your view function to a Jinja2 template.",
    "category": "templates",
    "method": "GET",
    "difficulty": "easy",
    "code": "# view.py\nfrom flask import render_template\n\n@app.route('/user/<username>')\ndef profile(username):\n    user_data = {'name': username, 'is_active': True}\n    return render_template('profile.html', user=user_data)\n\n# templates/profile.html\n\"\"\"<h1>Hello, {{ user.name }}!</h1>\n{% if user.is_active %}\n    <p>Your account is active.</p>\n{% endif %}\"\"\"",
    "keywords": ["flask", "template", "jinja2", "variable", "context"],
    "tags": ["flask", "templates", "jinja2"],
    "requires": ["Flask"],
    "notes": "Pass variables to `render_template()` as keyword arguments. You can then access these variables in the template using `{{ variable_name }}` syntax.",
    "related": ["template_render", "template_conditional"],
    "response": {
      "success": "Renders an HTML template populated with dynamic data.",
      "error": "N/A"
    }
  },
  {
    "id": "background_task_celery",
    "name": "Background Task with Celery",
    "description": "Offload a long-running task to a background worker using Celery.",
    "category": "miscellaneous",
    "method": "POST",
    "difficulty": "hard",
    "code": "# tasks.py\nfrom celery import Celery\n\ncelery = Celery('tasks', broker='redis://localhost:6379/0')\n\n@celery.task\ndef send_async_email(email_data):\n    # Logic to send an email\n    print(f\"Sending email to {email_data['to']}\")\n    # ...\n    return f\"Email sent to {email_data['to']}\"\n\n# app.py\nfrom flask import jsonify\nfrom .tasks import send_async_email\n\n@app.route('/send-email', methods=['POST'])\ndef send_email_endpoint():\n    email_data = {'to': 'test@example.com', 'subject': 'Hello'}\n    # .delay() sends the task to the Celery queue\n    task = send_async_email.delay(email_data)\n    return jsonify({'message': 'Email is being sent in the background', 'task_id': task.id}), 202",
    "keywords": ["flask", "celery", "background", "task", "worker", "async"],
    "tags": ["flask", "celery", "async", "tasks"],
    "requires": ["Flask", "Celery", "redis"],
    "notes": "Celery is a powerful distributed task queue. This setup requires a running Celery worker and a message broker like Redis or RabbitMQ. Using `.delay()` immediately returns control to the application, improving responsiveness.",
    "related": ["gunicorn_wsgi_entry"],
    "response": {
      "success": "Immediately returns a response while the task runs in the background.",
      "error": "N/A"
    }
  },
  {
    "id": "api_versioning_blueprint",
    "name": "API Versioning with Blueprints",
    "description": "A common pattern for versioning a REST API using blueprints and URL prefixes.",
    "category": "miscellaneous",
    "method": "N/A",
    "difficulty": "medium",
    "code": "# api/v1/routes.py\nfrom flask import Blueprint, jsonify\n\napi_v1 = Blueprint('api_v1', __name__)\n\n@api_v1.route('/data')\ndef get_data():\n    return jsonify({'version': '1.0', 'data': 'some data'})\n\n# api/v2/routes.py\nfrom flask import Blueprint, jsonify\n\napi_v2 = Blueprint('api_v2', __name__)\n\n@api_v2.route('/data')\ndef get_data():\n    return jsonify({'version': '2.0', 'data': 'some new and improved data'})\n\n# app.py\nfrom flask import Flask\nfrom api.v1.routes import api_v1\nfrom api.v2.routes import api_v2\n\napp = Flask(__name__)\napp.register_blueprint(api_v1, url_prefix='/api/v1')\napp.register_blueprint(api_v2, url_prefix='/api/v2')",
    "keywords": ["flask", "api", "versioning", "blueprint", "rest"],
    "tags": ["flask", "api", "blueprints", "structure"],
    "requires": ["Flask"],
    "notes": "This approach allows you to maintain different versions of your API simultaneously. Clients can choose which version to use by changing the URL, making it easier to introduce breaking changes without affecting existing users.",
    "related": ["blueprint_url_prefix", "create_blueprint"],
    "response": {
      "success": "Application serves multiple versions of an API under different URL prefixes.",
      "error": "N/A"
    }
  }
]
